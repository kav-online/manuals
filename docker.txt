КОМАНДЫ

docker version  -информация о клиенте и о сервере
docker ps -a  -список запущенных и остановленных контейнеров (без -a только запущенные)
docker images  -список локальных образов

docker run hello-world  -создание и запуск контейнера (hello-world название образа, если локально нет такого образа то он будет скачен с dockerhub)
docker run -i -t <image name>  -создание и запуск контейнера интерактивно (-i) и в терминале (-t)  (или просто -it)
docker run --rm <image name>  -создание и запуск контейнера, при остановке контейнер будет сразу удален (ключ --rm)
docker run -d <image name>  -создание и запуск контейнера в фоновом режиме (-d)
docker run -d --name <custom name> <image name>  -создание и запуск контейнера в фоновом режиме с кастомным именем <custom name>

docker run -p 8080:80 <image name>  -создание и запуск контейнера с маппингом портов: 80 порт контейнера пробрасывается на 8080 локальный (внешний) порт
docker run -v ${PWD}:/usr/share/nginx/html <image name> -создание и запуск контейнера с маппингом томов: папка /usr/share/nginx/html контейнера пробрасывается на локальную папку (${PWD}-переменная текущей папки, ее узнать команда echo ${pwd}) 
или
docker run -v C:\Users\a.kuznetsov\docker\nginx:/usr/share/nginx/html -p 8081:80 -d nginx  -(абсолютный путь, его узнать команда echo ${pwd})

docker rm <container id> или <names>  -удаление контейнера по id или имени
docker container prune  -удаление всех остановленных контейнеров
docker container inspect <container id>  -вывод информации о контейнере в тч ip
docker stop <container id>  -остановка контейнера
docker exec -it <container id> bash  -выполняет команду в запущенном контейнере, в этом случае bash (bash это оболочка типа cmd)(exit-выход из оболочки)
docker logs <container id>  -вывод логов контейнера 

длинные командные строки можно разбивать с помощью символа "\" следующим образом: 
docker run \
--name my-nginx \
-v ${pwd}:/usr/share/nginx/html \
=p 8081:80 \
-d \
--rm \
nginx

СОЗДАНИЕ ОБРАЗА

1. создать dockerfile  -обычно его размещают в корне папки приложения

пример dockerfila:
FROM python:alpine  -имя базового образа (python) и тег образа (alpine - самый минимальный)
WORKDIR /app  -создается рабочая папка приложения в контейнере и она станет текущей для всех последующих команд
RUN pip install pymongo  -не обязательно вызов команды, например установка внешнего пакета mongo для python        -   
COPY . .  -копирование файлов из текущей локальной папки (приложения) в рабочую папку в контейнере (/app)
CMD ["python","main.py"]  -выполнить команду (python) в контейнере с аргументом (main.py)

2. docker build .  -создание образа на основании dockerfile из текущей папки (dockerfile-имя по умолчанию)
или
docker build . -t my-calendar:4.1.3  -создание образа с именем (my-calendar) и тегом (4.1.3), если тег опустить то автоматом будет добавлен тег "latest"

DOCKER COMPOSE (формат YAML):

-все необходимые контейнеры запускаются одной командой
-могут автоматически создаются образы на основании dockerfile
-автоматически создается изолированная сеть для взаимодействия контейнеров от других контейнеров на этом же хосте
-благодаря DNS возможно взаимодействие между контейнерами на основании имен сервисов (ip контейнеров динамические а имена сервисов статические) 

пример файла:
version: '3'
services:
  app:                     -название сервиса
    build: ./              -создание кастомного образа на основании dockerfile из папки ./ и запуск контейнера
  mongo:                   -название сервиса   
    image: mongo           -запуск контейнера на основании официального образа mongo (будет скачен если нет в локальном репозитории)

docker-compose up  -запуск контейнеров
docker-compose up -d  -запуск контейнеров в фоновом режиме
docker-compose up -d --build  -запуск контейнеров в фоновом режиме c пересозданием всех образов
docker-compose down  -остановка и удаление контейнеров







